f = open('26_2.txt') # открываем файл к задаче

k, m, n = map(int, f.readline().split()) # считываем числа в первой строке

presents = [int(f.readline()[:-1]) for i in range(k)] # считываем все подарки в список presents
presents.sort() # сортируем вес подарков по возрастанию

small_presents = [] # создаём список для маленьких подарков и заполняем его
for i in range(k):
    if presents[i] > 900: # так как вес подарков отсортиван по возрастанию, то как только i-ый элемент списка presents
                          # превысит 900, начнутся большие подарки, поэтому в этот момент выходим из цикла
        break
    small_presents.append(presents[i])
big_presents = presents[len(small_presents):] # сейчас в списки маленьких подарков элементы списка presents
                                              # до len(small_presents) невключительно, а значит от этого значения
                                              # и до конца списка подарков все элементы весом >900

small_presents.sort(reverse=True) # так как маленькие подарки имеют вес, не превышающий 900 грамм, а большие весят
                                  # не меньше 1200, то некоторые маленькие подарки не возможно будет сложить
                                  # в большую упаковку, тогда следует все маленькие подарки с наибольшим весом сразу
                                  # сложить в маленькие упаковки
small_presents_left = small_presents[n:] # так как гарантируется, что маленьких упаковок меньше, чем маленьких подарков,
                                         # то все маленькие подарки в списке до n невключительно попадут в маленькие
                                         # упаковки, тогда останется маленьких подарков
                                         # от n и до конца списка small_presents
small_presents_left.sort() # чтобы максимально эффективно заполнять большие коробки следует брать маленький подарок,
                           # который остался, и искать к нему наименьший большой подарок так, чтобы их сумма была меньше
                           # или равна 2000(список с большими подарками отсортирован по возрастанию)
ans = 0 # переменная, в которой будет храниться число больших упаковок
index = 0 # переменная, в которой будет храниться последний индекс большой упаковки, наиболее подходящей для
          # текущей маленькой
for i in range(len(small_presents_left)): # так как в большой упаковке может храниться 2 и более подарка,
                                          # то будем подбирать для каждого оставшегося маленького подарка,
                                          # подходящий ему большой(большие начинаются с 1201, поэтому
                                          # в большой упаковке будет минимум 1 маленький подарок)
    if small_presents_left[i] < 800: # маленькие подарки могут быть весом <900, а значит некоторые нельзя будет
                                     # упаковать с большим подарком(к примеру, 801 + 1201 > 2000)
        for j in range(index, len(big_presents)): # перебираем большие подарки от index до длины всего списка
                                                  # больших подарков невключительно
            if big_presents[j] + small_presents_left[i] <= 2000: # если такой большой подарок подходит текущему
                                                                 # маленькому, то пересчитываем ans и меняем
                                                                 # index на j + 1, чтобы для следующего маленького
                                                                 # подарка искать оставшиеся большие
                ans += 1
                index = j + 1
                break # когда нашли, выходим из цикла

# теперь посчитаем какое наибольшее количество имеющихся подарков можно положить в большую упаковку
# для этого оптимальнее всего брать маленькие подарки
max_number_of_presents = 0 # переменная, которая будет хранить искомое количество
weight = 0 # вес на текущей итерации
small_presents.sort() # так как выше список маленьких подарков был отсортирован по убыванию, необходимо отсортировать
                      # его по возрастанию, чтобы наполнять большую упаковку подарками с наименьшим весом
for i in range(len(small_presents)): # перебираем весь список маленьких подарков
    if weight <= 2000: # проверяем, чтобы на текущей итерации вес не превышал 2000(вместимость большой упаковки)
        weight += small_presents[i] # если не превышает, то прибавляем к weight вес текущего маленького подарка
        max_number_of_presents += 1 # и обновляем количество подарков
    else: # если превышает, значит мы заполнили на максимум, выходим из цикла
        break

print(ans, max_number_of_presents) # выводим ответ: количество больших упаковок, которые можно будет продать
                                   # и максимальное количество имеющихся подарков, которые можно поместить в
                                   # большую упаковку
